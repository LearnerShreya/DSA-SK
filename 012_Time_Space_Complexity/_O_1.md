## **O(1) â€” Constant Time Examples**

> Execution time **does not depend on input size** `n`. Same number of steps every time.

---

### **1. Accessing an array element by index**

```cpp
int arr[] = {10, 20, 30, 40, 50};
cout << arr[3];  // Access element at index 3
```

âœ… Always takes the same time no matter how big `arr` is.
**Complexity:** **O(1)**

---

### **2. Assigning a value**

```cpp
int a = 100;  // Assignment
a += 5;       // Addition
```

âœ… Fixed number of steps, independent of `n`.
**Complexity:** **O(1)**

---

### **3. Swapping two variables**

```cpp
int a = 5, b = 10;
int temp = a;
a = b;
b = temp;
```

âœ… Three assignments, always constant time.
**Complexity:** **O(1)**

---

### **4. Checking if a number is even or odd**

```cpp
if (num % 2 == 0)
    cout << "Even";
else
    cout << "Odd";
```

âœ… Just one modulus operation, fixed time.
**Complexity:** **O(1)**

---

### **5. Returning the first element of an array/vector**

```cpp
vector<int> nums = {3, 6, 9, 12};
cout << nums.front();
```

âœ… Only one operation regardless of size.
**Complexity:** **O(1)**

---

### **6. Returning the largest element in a sorted array**

```cpp
vector<int> nums = {2, 5, 8, 12, 15}; // sorted ascending
cout << nums.back(); // last element
```

âœ… Direct access to the last index = constant time.
**Complexity:** **O(1)**

---

### **7. Calculating sum of first n natural numbers (formula)**

```cpp
int n = 100;
long long sum = (n * (n + 1)) / 2;
```

âœ… Always 3 operations: multiplication, addition, division.
**Complexity:** **O(1)**

---

ðŸ’¡ **Core Idea:**
No loops, no recursion, no input-size dependency â€” **fixed steps** = **O(1)**.

---